<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basic hypergraph operations &mdash; Graphbrain 0.6.0-dev documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.png"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Patterns" href="patterns.html" />
    <link rel="prev" title="Special relations" href="special-relations.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #333" >
            <a href="../index.html">
            <img src="../_static/graphbrain-logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
    <div>
    <a href="https://socsemics.huma-num.fr/" style="margin:0px; text-align:center">
        <img style="width: 75%; height: 75%; border-radius: 0px; margin:0px; padding:5px; background:#ffffff" src="/_static/socsemics.png"/>
    </a>
    </div>
    
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials and examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../manual.html">Manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="notation.html">Semantic Hypergraph notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="special-relations.html">Special relations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Basic hypergraph operations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-two-central-functions-of-graphbrain-hgraph-and-hedge">The two central functions of Graphbrain: hgraph() and hedge()</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-and-manipulating-hyperedges">Creating and manipulating hyperedges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-and-populating-hypergraphs">Creating and populating hypergraphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-many-hyperedges-as-a-batch-for-speed">Adding many hyperedges as a batch (for speed)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-neighborhood-of-a-hyperedge-star">The neighborhood of a hyperedge (star)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hyperedges-containing-a-given-set-of-hyperedges">Hyperedges containing a given set of hyperedges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#searching-for-hyperedges">Searching for hyperedges</a></li>
<li class="toctree-l3"><a class="reference internal" href="#degrees-and-deep-degrees">Degrees and deep degrees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hyperedge-attributes">Hyperedge attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#local-and-global-counters">Local and global counters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#working-with-hyperedge-sequences">Working with hyperedge sequences</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="patterns.html">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="discovering-patterns.html">Discovering patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="parsing.html">Parsing natural language</a></li>
<li class="toctree-l2"><a class="reference internal" href="readers.html">Readers</a></li>
<li class="toctree-l2"><a class="reference internal" href="corefs.html">Co-reference resolution</a></li>
<li class="toctree-l2"><a class="reference internal" href="meaning.html">Meaning extraction</a></li>
<li class="toctree-l2"><a class="reference internal" href="backends.html">Hypergraph database backends</a></li>
<li class="toctree-l2"><a class="reference internal" href="notebooks.html">Notebooks and visualizations</a></li>
<li class="toctree-l2"><a class="reference internal" href="cli.html">Command-line interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="internals.html">Internals and extending Graphbrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="api.html">API reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../team.html">Team</a></li>
<li class="toctree-l1"><a class="reference internal" href="../thanks.html">Thanks</a></li>
</ul>


        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #333" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Graphbrain</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../manual.html">Manual</a> &raquo;</li>
      <li>Basic hypergraph operations</li>
      <li class="wy-breadcrumbs-aside">
              <!-- User defined GitHub URL -->
              <a href="https://github.com/graphbrain/graphbrain" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="basic-hypergraph-operations">
<h1>Basic hypergraph operations<a class="headerlink" href="#basic-hypergraph-operations" title="Permalink to this headline"></a></h1>
<p>At the heart of Graphbrain lies the Semantic Hypergraph (SH). In practical terms, we will talk simply about <em>hypergraphs</em>, and we will treat them as a type of database, which contains a searchable collection of hyperedges.</p>
<p>Graphbrain provides abstractions to create, modify and search persistent hypergraph databases, as well as to define and manipulate hyperedges. In this section we introduce these basic operations, upon which all aspects of the library rely on.</p>
<section id="the-two-central-functions-of-graphbrain-hgraph-and-hedge">
<h2>The two central functions of Graphbrain: hgraph() and hedge()<a class="headerlink" href="#the-two-central-functions-of-graphbrain-hgraph-and-hedge" title="Permalink to this headline"></a></h2>
<p>The root namespace <code class="docutils literal notranslate"><span class="pre">graphbrain</span></code> contains the two most fundamental functions of the library:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hgraph(locator_string)</span></code>, which creates/opens a persistent hypergraph.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hedge(source)</span></code>, which creates a hyperedge from a string or a Python list or tuple.</p></li>
</ul>
<p>In fact, the latter is implemented in <code class="docutils literal notranslate"><span class="pre">graphbrain.hyperedge</span></code>, but it is imported to the root namespace by default for convenience. We will see that, with just these two functions, a lot can be achieved.</p>
</section>
<section id="creating-and-manipulating-hyperedges">
<h2>Creating and manipulating hyperedges<a class="headerlink" href="#creating-and-manipulating-hyperedges" title="Permalink to this headline"></a></h2>
<p>Graphbrain defines the object class <code class="docutils literal notranslate"><span class="pre">Hyperedge</span></code>, which provides a variety of methods to work with hyperedges. The full interface of this class is described in the API reference. However, these objects are not meant to be instantiated directly. Instead, the <code class="docutils literal notranslate"><span class="pre">hedge</span></code> function can be used to create such an object directly from a string representation conforming to the SH notation. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graphbrain</span> <span class="kn">import</span> <span class="n">hedge</span>
<span class="n">edge</span> <span class="o">=</span> <span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;(plays/P.so mary/C chess/C)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">edge</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">Hyperedge</span></code> class. Hyerpedges are Python sequences. In fact, the class <code class="docutils literal notranslate"><span class="pre">Hyperedge</span></code> is derived from <code class="docutils literal notranslate"><span class="pre">tuple</span></code>, so it makes it possible to do things such as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">person</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>In this case, <code class="docutils literal notranslate"><span class="pre">person</span></code> will be assigned the second element of the initial hyperedge, which happens to be the atom <code class="docutils literal notranslate"><span class="pre">mary/C</span></code>. Range selector also work, but they do not automatically produce hyperedges, because subranges of the element of a semantic hyperedge are not guaranteed to be valid semantic hyperedges themselves. Instead, simple tulpes are returned. For example, <code class="docutils literal notranslate"><span class="pre">edge[1:]</span></code> from the example is not a valid hyperedge. Nevertheless, such tuples of hyperedges are often useful:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
<span class="go">(mary/C, chess/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
<span class="go">&lt;class &#39;tuple&#39;&gt;</span>
</pre></div>
</div>
<p>It is possible to test a hyperedge for atomicity like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">edge</span><span class="o">.</span><span class="n">is_atom</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">person</span><span class="o">.</span><span class="n">is_atom</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Another frequently useful task if that of determining the type of a hyperedge:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">edge</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;R&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;P&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">person</span><span class="o">.</span><span class="n">type</span><span class="p">()</span>
<span class="go">&#39;C&#39;</span>
</pre></div>
</div>
</section>
<section id="creating-and-populating-hypergraphs">
<h2>Creating and populating hypergraphs<a class="headerlink" href="#creating-and-populating-hypergraphs" title="Permalink to this headline"></a></h2>
<p>Graphbrain hypergraphs are created and/or opened like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graphbrain</span> <span class="kn">import</span> <span class="n">hgraph</span>
<span class="n">hg</span> <span class="o">=</span> <span class="n">hgraph</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The argument <code class="docutils literal notranslate"><span class="pre">'example.db'</span></code> corresponds to a local file in the filesystem, where the hypergraph is persisted. A full path can also be provided, e.g.: <code class="docutils literal notranslate"><span class="pre">hgraph('users/alice/books.db')</span></code>. The object returned by this function is of type <code class="docutils literal notranslate"><span class="pre">Hypergraph</span></code>. Like <code class="docutils literal notranslate"><span class="pre">Hyperedge</span></code>, it provides a number of general-purpose methods to work with hypergraphs and is not meant to be directly instantiated.</p>
<p>Graphbrain comes with a default implementation of hypergraph database based on SQLite 3. This is a nice general-purpose option, because it is available in all popular operating systems and Python comes with native support for it. Files with extensions <code class="docutils literal notranslate"><span class="pre">.db</span></code>, <code class="docutils literal notranslate"><span class="pre">.sqlite</span></code> or <code class="docutils literal notranslate"><span class="pre">.sqlite3</span></code> will be opened as SQLite-based hypergraph databases. For other options, see <a class="reference external" href="/manual/backends.html">the section on hypergraph database backends</a>. One possible disadvantage of SQLite is that it is not very space-efficient. This can become a problem with large hypergraphs, and a better option in this case might be the LevelDB-based hypergraph database. This backend is not included by default because it is currently hard to install outside of Linux. To support LevelDB, you will need to build Graphbrain from source with a special option, <a class="reference external" href="/installation.html#building-graphbrain-with-support-for-leveldb-hypergraph-databases">as explained in the installation instructions</a>.</p>
<p>Adding hyperedges to a hypergraph is simple. For example, let us add the edge that was defined above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then check if this edge exists in the hypergraph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Notice that adding a hyperedge to a hypergraph implies the recursive addition of all of the elements of the hyperedge, so it is also the case that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">True</span>
</pre></div>
</div>
<p>A distinction is made with the notion of <em>primary hyperedge</em>. A primary hyperedge is, by default, one that was added directly, while the recursively added ones are considered non-primary. It is possible to check this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">is_primary</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">is_primary</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">False</span>
</pre></div>
</div>
<p>It is possible to add an edge as non-primary:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">moon</span> <span class="o">=</span> <span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;(of/B.ma moon/C jupiter/C)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">moon</span><span class="p">,</span> <span class="n">primary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(of/B.ma moon/C jupiter/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">is_primary</span><span class="p">(</span><span class="n">moon</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>As with <code class="docutils literal notranslate"><span class="pre">Hyperedge</span></code>, the full range of methods of <code class="docutils literal notranslate"><span class="pre">Hypergraph</span></code> is documented in the API reference.</p>
</section>
<section id="adding-many-hyperedges-as-a-batch-for-speed">
<h2>Adding many hyperedges as a batch (for speed)<a class="headerlink" href="#adding-many-hyperedges-as-a-batch-for-speed" title="Permalink to this headline"></a></h2>
<p>With some hypergraph database backends, as is the case for the default one (SQLite 3), adding a large number of edges can be much faster if done in a batch. To help define such bath operations, Graphbrain includes the <code class="docutils literal notranslate"><span class="pre">hopen()</span></code> context manager, to be used with Python’s <code class="docutils literal notranslate"><span class="pre">with</span></code> statements. This works in a very similarly to the <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">open...</span></code> expressions often used with files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">hopen</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hg</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">large_edge_list</span><span class="p">:</span>
        <span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
</pre></div>
</div>
<p>Since it never hurts performance, it is advisable to always use <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">hopen...</span></code> when adding large number of hyperedges to a hypergraph database.</p>
</section>
<section id="the-neighborhood-of-a-hyperedge-star">
<h2>The neighborhood of a hyperedge (star)<a class="headerlink" href="#the-neighborhood-of-a-hyperedge-star" title="Permalink to this headline"></a></h2>
<p>Hypergraphs are fundamentally about relationships. In an analogous fashion to graphs/networks, the neighborhood of an entity (other entities that it is directly connected to) is a simple but powerful concept. With graphbrain, the <code class="docutils literal notranslate"><span class="pre">star()</span></code> method provides one type of neighborhood that is particularly natural for hypergraphs and has wide applicability: it produces the set of hyperedges that contain a given hyperedge. For example, let us populate a hypergraph like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;(of/B.ma moon/C jupiter/C)&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;(of/B.ma moon/C saturn/C)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Se let us obtain the star of the atom <code class="docutils literal notranslate"><span class="pre">moon/C</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;moon/C&#39;</span><span class="p">))</span>
<span class="go">&lt;generator object at 0x102382d30&gt;</span>
</pre></div>
</div>
<p>It returns a generator, allowing for the iteration through a very large number of hyperedges without exhausting memory. In this case, let us just convert the generator into a list to see the results:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;moon/C&#39;</span><span class="p">)))</span>
<span class="go">[(of/B.ma moon/C jupiter/C), (of/B.ma moon/C saturn/C)]</span>
</pre></div>
</div>
<p>Let us combine several of the previous ideas to define a specific type of neighborhood: the set of hyperedges of type concept that are directly connected to <code class="docutils literal notranslate"><span class="pre">moon/C</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">concepts</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">hg</span><span class="o">.</span><span class="n">star</span><span class="p">(</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;moon/C&#39;</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">subedge</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
            <span class="n">concepts</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">subedge</span><span class="p">)</span>
</pre></div>
</div>
<p>The set <code class="docutils literal notranslate"><span class="pre">concepts</span></code> will then contain: <code class="docutils literal notranslate"><span class="pre">moon/C</span></code>, <code class="docutils literal notranslate"><span class="pre">jupiter/C</span></code>, <code class="docutils literal notranslate"><span class="pre">saturn/C</span></code>.</p>
</section>
<section id="hyperedges-containing-a-given-set-of-hyperedges">
<h2>Hyperedges containing a given set of hyperedges<a class="headerlink" href="#hyperedges-containing-a-given-set-of-hyperedges" title="Permalink to this headline"></a></h2>
<p>The hypergraph database provides a very efficient way to query for all hyperedges that include a given set of hyperedges, with the method <code class="docutils literal notranslate"><span class="pre">edges_with_edges()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(plays/P mary/C chess/C)&#39;</span><span class="p">)</span>
<span class="go">(plays/P mary/C chess/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(plays/P john/C chess/C)&#39;</span><span class="p">)</span>
<span class="go">(plays/P john/C chess/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(plays/P alice/C handball/C)&#39;</span><span class="p">)</span>
<span class="go">(plays/P alice/C handball/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">edges_with_edges</span><span class="p">([</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;plays/P&#39;</span><span class="p">),</span> <span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;chess/C&#39;</span><span class="p">)]))</span>
<span class="go">[(plays/P john/C chess/C), (plays/P mary/C chess/C)]</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">root</span></code> argument can be added, further requiring the matching edges to contain an atom with that root (at the top level):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">edges_with_edges</span><span class="p">([</span><span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;plays/C&#39;</span><span class="p">),</span> <span class="n">hedge</span><span class="p">(</span><span class="s1">&#39;chess/C&#39;</span><span class="p">)],</span> <span class="n">root</span><span class="o">=</span><span class="s1">&#39;john&#39;</span><span class="p">))</span>
<span class="go">[(plays/C john/C chess/C)]</span>
</pre></div>
</div>
</section>
<section id="searching-for-hyperedges">
<h2>Searching for hyperedges<a class="headerlink" href="#searching-for-hyperedges" title="Permalink to this headline"></a></h2>
<p>Another fundamental way to query a hyperedge is by search patterns. Search patterns are templates that match hyperedges. Graphbrain provides a sophisticated pattern language that allows for semantically rich modes of matching. This will be discussed in greater detail in the next section. For now, let us just consider the wildcard <code class="docutils literal notranslate"><span class="pre">*</span></code>, which matches any hyperedge (atomic or not). For example, the pattern <code class="docutils literal notranslate"><span class="pre">(of/B.ma</span> <span class="pre">*</span> <span class="pre">*)</span></code> matches both of the previously defined hyperedges. The <code class="docutils literal notranslate"><span class="pre">search()</span></code> method of <code class="docutils literal notranslate"><span class="pre">Hypergraph</span></code> allows for search using these patterns. Like <code class="docutils literal notranslate"><span class="pre">star()</span></code>, it returns a generator:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;(of/B.ma * *)&#39;</span><span class="p">))</span>
<span class="go">[(of/B.ma moon/C jupiter/C), (of/B.ma moon/C saturn/C)]</span>
</pre></div>
</div>
</section>
<section id="degrees-and-deep-degrees">
<h2>Degrees and deep degrees<a class="headerlink" href="#degrees-and-deep-degrees" title="Permalink to this headline"></a></h2>
<p>In conventional graph theory, there is the notion of the degree of a node, which is the number of other nodes that it is directly connected to. This is a simple but generally useful measure of the <em>centrality</em> of a node in the graph. In hypergraphs we can also have the same notion of degree, with the only difference that a single hyperedge can connect one entity to several others. Graphbrain keeps track of the degree of every hyperedge, and the <code class="docutils literal notranslate"><span class="pre">Hypergraph</span></code> class provides a method to obtain it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">graphbrain</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span> <span class="o">=</span> <span class="n">hgraph</span><span class="p">(</span><span class="s1">&#39;example.db&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p>The degree of any hyperedge that does not exist in the hypergraph is 0. Notice also that <code class="docutils literal notranslate"><span class="pre">degree()</span></code>, as well as many other <code class="docutils literal notranslate"><span class="pre">Hypergraph</span></code> methods, conveniently accept the string representation of hyperedge, and transparently perform the conversion.</p>
<p>Let us add a few hyperedges and check the resulting degrees:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(in/B alice/C wonderland/C)&#39;</span><span class="p">)</span>
<span class="go">(in/B alice/C wonderland/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s1">&#39;(in/B alice/C wonderland/C)&#39;</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(reads/P john/C (in/B alice/C wonderland/C))&#39;</span><span class="p">)</span>
<span class="go">(reads/P john/C (in/B alice/C wonderland/C))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s1">&#39;(in/B alice/C wonderland/C)&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(plays/P alice/C chess/C)&#39;</span><span class="p">)</span>
<span class="go">(plays/P alice/C chess/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Given that hyperedges can contain recursively contain other hyperedges, we can also consider the <em>deep degree</em>, which takes into account deep connections. For example, consider the edge <code class="docutils literal notranslate"><span class="pre">(reads/P</span> <span class="pre">john/C</span> <span class="pre">(in/B</span> <span class="pre">alice/C</span> <span class="pre">wonderland/C))</span></code>. For the calculation of degrees, <code class="docutils literal notranslate"><span class="pre">john/C</span></code> is not considered here to be connected to <code class="docutils literal notranslate"><span class="pre">alice/C</span></code>, but such a connection is counter for the deep degree:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">deep_degree</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</section>
<section id="hyperedge-attributes">
<h2>Hyperedge attributes<a class="headerlink" href="#hyperedge-attributes" title="Permalink to this headline"></a></h2>
<p>The hypergraph database allows for the association of attributes to hyperedges. These can be strings, integer or floats, and are identified by a label. For example, one can associate a hyperedge to the text that it corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;(in/B alice/C wonderland/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">,</span> <span class="s1">&#39;Alice in Wonderland&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_str_attribute</span><span class="p">(</span><span class="s1">&#39;(in/B alice/C wonderland/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;text&#39;</span><span class="p">)</span>
<span class="go">&#39;Alice in Wonderland&#39;</span>
</pre></div>
</div>
<p>Notice that the method <code class="docutils literal notranslate"><span class="pre">set_attribute()</span></code> is used to set attributes of any type, but it is up to the programmer to choose the getter method according to the desired output type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_int_attribute</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
<span class="go">7</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_float_attribute</span><span class="p">(</span><span class="s1">&#39;alice/C&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">)</span>
<span class="go">1.2</span>
</pre></div>
</div>
<p>In fact, this is how degrees and deep degrees are stored, respectively in the attributes “d” and “dd”, so these attribute names should not be used for other purposes. The call <code class="docutils literal notranslate"><span class="pre">hg.degree(edge)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">hg.get_int_attribute(edge,</span> <span class="pre">'d')</span></code>.</p>
<p>Integer attributes can also be incremented and decremented:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(red/M button/C)&#39;</span><span class="p">)</span>
<span class="go">(red/M button/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">set_attribute</span><span class="p">(</span><span class="s1">&#39;(red/M button/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;clicks&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">inc_attribute</span><span class="p">(</span><span class="s1">&#39;(red/M button/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;clicks&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_int_attribute</span><span class="p">(</span><span class="s1">&#39;(red/M button/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;clicks&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">dec_attribute</span><span class="p">(</span><span class="s1">&#39;(red/M button/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;clicks&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_int_attribute</span><span class="p">(</span><span class="s1">&#39;(red/M button/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;clicks&#39;</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</section>
<section id="local-and-global-counters">
<h2>Local and global counters<a class="headerlink" href="#local-and-global-counters" title="Permalink to this headline"></a></h2>
<p>Normally, when adding a hyperedge that already exists, nothing is changed. It is sometimes useful to count occurrences while adding hyperedges, and in this case the <code class="docutils literal notranslate"><span class="pre">count=True</span></code> optional argument can be specified when calling <code class="docutils literal notranslate"><span class="pre">add()</span></code>. This increments the <code class="docutils literal notranslate"><span class="pre">count</span></code> integer argument of the hyperedge every time it is added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(counting/P sheep/C)&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(counting/P sheep/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_int_attribute</span><span class="p">(</span><span class="s1">&#39;(counting/P sheep/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;(counting/P sheep/C)&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(counting/P sheep/C)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">get_int_attribute</span><span class="p">(</span><span class="s1">&#39;(counting/P sheep/C)&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
<p>The hypergraph database also provides the following global counters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Hypergraph.atom_count()</span></code>: total number of atoms</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hypergraph.edge_count()</span></code>: total number of hyperedges</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hypergraph.primary_atom_count()</span></code>: total number of primary atoms</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Hypergraph.primary_edge_count()</span></code>: total number of primary hyperedges</p></li>
</ul>
</section>
<section id="working-with-hyperedge-sequences">
<h2>Working with hyperedge sequences<a class="headerlink" href="#working-with-hyperedge-sequences" title="Permalink to this headline"></a></h2>
<p>The hypergraph database provides for a mechanism to organize hyperedges into sequences. This is useful when storing hyperedges extracted from natural language sources where the order in which they appear can be relevant. For example, we might be interested in parsing every sentence in a book into a hyperedge and then being able to know which hyperedges correspond to the sentence that came before and after.</p>
<p>A hyperedge can be added to the end of a given sequence in the hypergraph (identified by a string label). For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add_to_sequence</span><span class="p">(</span><span class="s1">&#39;sentences&#39;</span><span class="p">,</span> <span class="s1">&#39;(is/P this/C (the/M (first/M sentence/C)))&#39;</span><span class="p">)</span>
<span class="go">(seq/P/. sentences 0 (is/P this/C (the/M (first/M sentence/C))))</span>
</pre></div>
</div>
<p>The outer edge with the special predicate <code class="docutils literal notranslate"><span class="pre">seq/P/.</span></code> assigns the hyperedge to the sequence “sentences” at position 0. Furthermore, for every sequence a special hyperedge is created to store attributes related to the sequence:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">seq_attrs</span><span class="o">/</span><span class="n">P</span><span class="o">/.</span> <span class="n">sentences</span><span class="p">)</span>
</pre></div>
</div>
<p>In its current implementation, this is used only to store the current size of the sequence as an integer under attribute ‘size’. This attribute is used and updated by <code class="docutils literal notranslate"><span class="pre">hg.add_to_sequence()</span></code>, to determine the position at which to insert the next element in the sequence.</p>
<p>The method <code class="docutils literal notranslate"><span class="pre">sequences()</span></code> returns a generator for all the sequences contained in the hypergraph:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">sequences</span><span class="p">())</span>
<span class="go">[sentences]</span>
</pre></div>
</div>
<p>The method <code class="docutils literal notranslate"><span class="pre">sequence()</span></code> provides a generator for all the hyperedges contained in a given sequence, in order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add_to_sequence</span><span class="p">(</span><span class="s1">&#39;sentences&#39;</span><span class="p">,</span> <span class="s1">&#39;(is/P this/C (the/M (second/M sentence/C)))&#39;</span><span class="p">)</span>
<span class="go">(seq/P/. sentences 1 (is/P this/C (the/M (second/M sentence/C))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span><span class="o">.</span><span class="n">add_to_sequence</span><span class="p">(</span><span class="s1">&#39;sentences&#39;</span><span class="p">,</span> <span class="s1">&#39;(is/P this/C (the/M (third/M sentence/C)))&#39;</span><span class="p">)</span>
<span class="go">(seq/P/. sentences 2 (is/P this/C (the/M (third/M sentence/C))))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">sequence</span><span class="p">(</span><span class="s1">&#39;sentences&#39;</span><span class="p">))</span>
<span class="go">[(is/P this/C (the/M (first/M sentence/C))), (is/P this/C (the/M (second/M sentence/C))), (is/P this/C (the/M (third/M sentence/C)))]</span>
</pre></div>
</div>
<p>No methods are provided to remove hyperedges from the sequence, or to insert hyperedges somewhere other than the end of the sequence. This is meant to be a very simple and fast mechanism.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="special-relations.html" class="btn btn-neutral float-left" title="Special relations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="patterns.html" class="btn btn-neutral float-right" title="Patterns" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021 CNRS.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>